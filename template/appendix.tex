\documentclass[../main.tex]{subfiles}

\begin{document}

\appendix

\section{Code changes}


\begin{code}{title=MPI initialization,label=code:mpi-init}{C}
    int main(int argc, char *argv[]) {
        // ... Other initializations
        double start_time, end_time;
        int rank, size;
        
        MPI_Init(&argc, &argv);
        MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        MPI_Comm_size(MPI_COMM_WORLD, &size);
        
        if (argc != 4)
        {
            printf("Usage: heat_mpi <size> <steps> <name_output_file>\n");
            MPI_Finalize();
            return 1;
        }

        if (rank == 0) start_time = MPI_Wtime();

        // Local size of the process
        int base_rows = nx / size;
        int remainder = nx % size;
        int local_nx = base_rows + (rank < remainder ? 1 : 0);

        // Allocate grid with 2 extra rows for ghost rows
        double *grid = (double *)calloc((local_nx + 2) * ny, sizeof(double));
        double *new_grid = (double *)calloc((local_nx + 2) * ny, sizeof(double));
        // ... Heat solving
    }
\end{code}


\begin{code}{title=Heat grid initialization,label=code:heat-init}{C}
void initialize_grid(double *grid, int nx, int ny, int rank, int size, int local_nx)
{
    int base_rows = nx / size;
    int extra = nx % size;
    int row_offset = rank * base_rows + (rank < extra ? rank : extra);
    int i, j, global_i;
    double value;

#pragma omp parallel for collapse(2) private(i, j, global_i, value)
    for (i = 1; i <= local_nx; i++)
    {
        for (j = 0; j < ny; j++)
        {
            global_i = row_offset + i - 1;
            value = 0.0;

            if (global_i != 0 && global_i != nx - 1 && j != 0 && j != ny - 1)
            {
                if (global_i == j || global_i == nx - 1 - j)
                {
                    value = T;
                }
            }

            grid[i * ny + j] = value;
        }
    }
}
\end{code}

\begin{code}{title=Heat calculations,label=code:heat-calculation}{C}
void solve_heat_equation(double *grid, double *new_grid, int steps, double r, int ny, int local_nx, int rank, int size) 
{
    double *temp;
    int i, j, step, global_i;
    int is_first = (rank == 0);
    int is_last = (rank == size - 1);
    int idx;

    for (step = 1; step < steps; step++)
    {
        // Exchange ghost rows
        if (!is_first)
        {
            MPI_Sendrecv(&grid[1 * ny], ny, MPI_DOUBLE, rank - 1, 0,
                        &grid[0 * ny], ny, MPI_DOUBLE, rank - 1, 1,
                        MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        }
        if (!is_last)
        {
            MPI_Sendrecv(&grid[local_nx * ny], ny, MPI_DOUBLE, rank + 1, 1,
                        &grid[(local_nx + 1) * ny], ny, MPI_DOUBLE, rank + 1, 0,
                        MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        }

#pragma omp parallel for private(i, j) collapse(2)
        for (i = 1; i <= local_nx; i++)
        {
            for (j = 1; j < ny - 1; j++)
            {
                idx = i * ny + j;
                new_grid[idx] = grid[idx]
                                + r * (grid[idx + ny] + grid[idx - ny] - 2 * grid[idx])
                                + r * (grid[idx + 1] + grid[idx - 1] - 2 * grid[idx]);
            }
        }

        temp = grid;
        grid = new_grid;
        new_grid = temp;
    }
}
\end{code}

\begin{code}{title=MPI gathering,label=code:mpi-gathering}{C}
    int main(int argc, char *argv[]) {
        // ... Heat solving

        double *full_grid = NULL;
        int *recvcounts = NULL, *displs = NULL;
        
        if (rank == 0)
        {
            full_grid = malloc(nx * ny * sizeof(double));
            recvcounts = malloc(size * sizeof(int));
            displs = malloc(size * sizeof(int));

            int offset = 0;
            int i;
            for (i = 0; i < size; i++)
            {
                int rows = base_rows + (i < remainder ? 1 : 0);
                recvcounts[i] = rows * ny;
                displs[i] = offset;
                offset += rows * ny;
            }
        }

        MPI_Gatherv(&grid[1 * ny], local_nx * ny, MPI_DOUBLE,
                    full_grid, recvcounts, displs, MPI_DOUBLE,
                    0, MPI_COMM_WORLD);
        // ...
    } 
\end{code}

\begin{code}{title=BMP file generation call and program finalization,label=code:bmp-file}{C}
    int main(int argc, char *argv[]) {
        // ... MPI gathering
        if (rank == 0)
        {
            FILE *file = fopen(argv[3], "wb");
            if (!file)
            {
                fprintf(stderr, "Failed to open output file\n");
                MPI_Abort(MPI_COMM_WORLD, 1);
            }
            write_bmp_header(file, nx, ny);
            write_grid(file, full_grid, nx, ny);
            fclose(file);

            end_time = MPI_Wtime();
            printf("Execution Time = %fs for %dx%d grid and %d steps\n", end_time - start_time, nx, ny, steps);

            free(full_grid);
            free(recvcounts);
            free(displs);
        }

        // Free allocated memory
        free(grid);
        free(new_grid);
        MPI_Finalize();

        return 0;
    }
\end{code}



\end{document}